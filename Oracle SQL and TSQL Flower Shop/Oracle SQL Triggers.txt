--2 SELECT STATEMENTS THAT INCLUDES AT LEAST TWO TABLES AND CONTAINS WHERE CLAUSE
--FIND ALL CUSTOMERS FROM WARSAW

SELECT C.*
FROM CUSTOMER C JOIN CITY ON C.CUSTCITY = CITY.IDCITY
WHERE CITY.CITY = 'WARSAW';

--FIND ALL FLOWERS THAT ARE WHITE

SELECT F.*
FROM FLOWER F JOIN COLOR C ON F.IDCOLOR = C.IDCOLOR
WHERE C.COLOR = 'WHITE';

-- 2 SELECT STATEMENTS WITH AGGREGATE FUNCTIONS
--FOR EACH PURCHASE, CALCULATE TOTAL PURCHASE

SELECT P.IDPURCHASE, SUM(PI.QUANTITY * F.PRICE) "TOTAL PURCHASE"
FROM PURCHASEITEM PI JOIN PURCHASE P ON PI.IDPURCHASE = P.IDPURCHASE
                    JOIN FLOWER F ON PI.IDFLOWER = F.IDFLOWER
GROUP BY P.IDPURCHASE
ORDER BY P.IDPURCHASE;

--FOR EACH CUSTOMER, CALCULATE AVERAGE AMOUNT OF MONEY THEY SPENT

SELECT SO.IDCUSTOMER, AVG(SI.SALEQUANTITY * F.PRICE) "AVERAGE"
FROM SALEORDER SO JOIN SALEITEM SI ON SO.IDSALEORDER = SI.IDSALEORDER
                JOIN FLOWER F ON SI.IDFLOWER = F.IDFLOWER
GROUP BY SO.IDCUSTOMER
ORDER BY SO.IDCUSTOMER;

--1 SELECT STATEMENT WITH SUBQUERY
--FIND CUSTOMER THAT BUY THE MOST

SELECT SO.IDCUSTOMER, SUM(SI.SALEQUANTITY * F.PRICE) "TOTAL SALE"
FROM SALEITEM SI JOIN SALEORDER SO ON SI.IDSALEORDER = SO.IDSALEORDER
                JOIN FLOWER F ON SI.IDFLOWER = F.IDFLOWER
GROUP BY SO.IDCUSTOMER                
HAVING SUM(SI.SALEQUANTITY * F.PRICE) = (SELECT MAX(SUM(SI.SALEQUANTITY * F.PRICE))
                                        FROM SALEITEM SI JOIN FLOWER F ON SI.IDFLOWER = F.IDFLOWER
                                                    JOIN SALEORDER SO ON SI.IDSALEORDER = SO.IDSALEORDER
                                        GROUP BY SO.IDCUSTOMER);

--1 SELECT STATEMENT WITH CORRELATED SUBQUERY
--SELECT EMPLOYEES THAT HAVE THE LOWEST SALARY IN THEIR CITY

SELECT E.EMPCITY, E.IDEMPLOYEE, E.EMPNAME, E.EMPSURNAME, E.SALARY
FROM EMPLOYEE E
WHERE E.SALARY = (SELECT MIN(E2.SALARY)
                FROM EMPLOYEE E2
                WHERE E.EMPCITY = E2.EMPCITY
                GROUP BY E2.EMPCITY);
                
-----------------------------------------------

--TRIGGERS 

--1 BEFORE STATEMENT TRIGGER (FOR INSERT, UPDATE AND DELETE STATEMENTS)
--BEFORE UPDATING SALARY, CHECK IF NEW SALARY IS SMALLER THAN 
--THE AVERAGE AMOUNT OF MONEY WHICH THAT EMPLOYEE SELLS
--IF NOT, DO NOT CHANGE SALARY

SET SERVEROUT ON;
CREATE OR REPLACE TRIGGER CHANGE_SALARY
BEFORE UPDATE ON EMPLOYEE 
FOR EACH ROW 
DECLARE 
    V_SALE INT;
BEGIN 
    SELECT SUM(SI.SALEQUANTITY * F.PRICE) INTO V_SALE 
    FROM SALEITEM SI JOIN SALEORDER SO ON SO.IDSALEORDER = SI.IDSALEORDER
                    JOIN FLOWER F ON F.IDFLOWER = SI.IDFLOWER
    WHERE SO.IDEMPLOYEE = IDEMPLOYEE;
    IF :NEW.SALARY > V_SALE THEN 
        :NEW.SALARY := :OLD.SALARY; 
        DBMS_OUTPUT.PUT_LINE('CAN NOT UPDATE SALARY');
    END IF;  
END;
/

UPDATE EMPLOYEE
SET SALARY = 1000000
WHERE IDEMPLOYEE = 2001;

SELECT * FROM EMPLOYEE;

--1 AFTER STATEMENT TRIGGER (FOR INSERT, UPDATE AND DELETE STATEMENTS)
--CREATE TABLE SUMOFSALARY TO SAVE THE HISTORY OF CHANGING SALARY
--AFTER CHANGING EMPLOYEE INFORMATION, UPDATE NUMBER OF EMPLOYEES AND SUM OF SALARY IN TABLE SUMOFSALARY

DROP TABLE SUMOFSALARY;
CREATE TABLE SUMOFSALARY
    (NUMBEROFEMPLOYEE INT, 
    SALARYSUM INT );
    
INSERT INTO SUMOFSALARY(NUMBEROFEMPLOYEE, SALARYSUM) 
SELECT COUNT(*), SUM(SALARY) FROM EMPLOYEE ; 

CREATE OR REPLACE TRIGGER SUM_OF_SALARY_FOR_EMPLOYEE
AFTER UPDATE OR INSERT ON EMPLOYEE 
BEGIN
        INSERT INTO SUMOFSALARY(NUMBEROFEMPLOYEE, SALARYSUM) 
        SELECT COUNT(*), SUM(SALARY) FROM EMPLOYEE ; 
END;
/

UPDATE EMPLOYEE
SET SALARY = 2000
WHERE IDEMPLOYEE = 2001;

SELECT * FROM SUMOFSALARY;
